.data	
array:	.byte
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,
3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	

msg_game_over:	.asciiz "Game over!"
msg_lives_left:	.asciiz "Lives left: "
msg_newline:	.asciiz	"\n"
msg_player_score: .asciiz "Your score is: "
player_lives:	.byte	3
player_score:	.word	0

velocities:	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

stone1_v: 	.byte 1
stone1_color:	.byte 2
stone1_length:	.byte 8

stone2_v: 	.byte 3
stone2_color:	.byte 2
stone2_length:	.byte 12

stone3_v: 	.byte 6
stone3_color:	.byte 2
stone3_length:	.byte 8

stone4_v: 	.byte 9
stone4_color:	.byte 2
stone4_length:	.byte 12

stone5_v: 	.byte 12
stone5_color:	.byte 2
stone5_length:	.byte 8

stone6_v: 	.byte 15
stone6_color:	.byte 2
stone6_length:	.byte 12

.text

main:
	# -------------
	# Let's do this
	# -------------

	jal	generate_velocities


	reset_game:
	li 	$s0, 31			# Store the initial x position of the frog
	li	$s1, 56			# Store the initial y position of the frog

	# Generate the initial playing field
	jal	draw_field
	
	game_loop:	 
	li	$a0, 200
	li	$v0, 32
	syscall				# Pause for 200 miliseconds
	
	# perform all game operations (generate stones, move stones, etc)


#  Move all stones by their velocities
# --------------------------------------	
	lb	$s3, stone1_v		#load the velocity of stone 1 into $s2

	stone1_velocity_loop:
	beqz	$s3, stone2_begin_move	# if the stone has already moved over 'velocity' times,
					# begin to move stone 2

	li	$a0, 8			# load the top row of stone 1
	la	$a1, stone1_length	# load the length of stone 1
	la	$a2, stone1_color	# load the color of stone 1 (will be red when no stone is being generated)
	jal	move_stone_left	# move the entire stone right by one pixel
	addi	$s3, $s3, -1		# subtract 1 from the velocity and do it again!
	j	stone1_velocity_loop

	stone2_begin_move:
	lb	$s3, stone2_v
	
	stone2_velocity_loop:
	beqz	$s3, stone3_begin_move 	# if the stone has already moved over 'velocity' times,
					# begin to move stone 2

	li	$a0, 16			# load the top row of stone 2
	la	$a1, stone2_length	# load the length of stone 2
	la	$a2, stone2_color	# load the color of stone 2 (will be red when no stone is being generated)
	jal	move_stone_right	# move the entire stone right by one pixel
	addi	$s3, $s3, -1		# subtract 1 from the velocity and do it again!
	j	stone2_velocity_loop

	stone3_begin_move:
	lb	$s3, stone3_v

	stone3_velocity_loop:
	beqz	$s3, stone4_begin_move	# if the stone has already moved over 'velocity' times,
					# begin to move stone 2

	li	$a0, 24			# load the top row of stone 3
	la	$a1, stone3_length	# load the length of stone 3
	la	$a2, stone3_color	# load the color of stone 3 (will be red when no stone is being generated)
	jal	move_stone_left		# move the entire stone right by one pixel
	addi	$s3, $s3, -1		# subtract 1 from the velocity and do it again!
	j	stone3_velocity_loop
	
	stone4_begin_move:
	lb	$s3, stone4_v
	
	stone4_velocity_loop:
	beqz	$s3, stone5_begin_move	# if the stone has already moved over 'velocity' times,
					# begin to move stone 2

	li	$a0, 32			# load the top row of stone 4
	la	$a1, stone4_length	# load the length of stone 4
	la	$a2, stone4_color	# load the color of stone 4 (will be red when no stone is being generated)
	jal	move_stone_right	# move the entire stone right by one pixel
	addi	$s3, $s3, -1		# subtract 1 from the velocity and do it again!
	j	stone4_velocity_loop

	stone5_begin_move:
	lb	$s3, stone5_v

	stone5_velocity_loop:
	beqz	$s3, stone6_begin_move # if the stone has already moved over 'velocity' times,
					# begin to move stone 2

	li	$a0, 40			# load the top row of stone 5
	la	$a1, stone5_length	# load the length of stone 5
	la	$a2, stone5_color	# load the color of stone 5 (will be red when no stone is being generated)
	jal	move_stone_left	# move the entire stone right by one pixel
	addi	$s3, $s3, -1		# subtract 1 from the velocity and do it again!
	j	stone5_velocity_loop

	stone6_begin_move:
	lb	$s3, stone6_v

	stone6_velocity_loop:
	beqz	$s3, end_stone_moves	# if the stone has already moved over 'velocity' times,
					# begin to move stone 2

	li	$a0, 48			# load the top row of stone 6
	la	$a1, stone6_length	# load the length of stone 6
	la	$a2, stone6_color	# load the color of stone 6 (will be red when no stone is being generated)
	jal	move_stone_right	# move the entire stone right by one pixel
	addi	$s3, $s3, -1		# subtract 1 from the velocity and do it again!
	j	stone6_velocity_loop
	
end_stone_moves:

# Update the frog's position with the
# movement of the rocks
# -------------------------------------
	la	$t0, velocities
	add	$t0, $t0, $s1
	
	lb	$t1, 0($t0)
	
	add	$s0, $s0, $t1
	
#            Spawn new rocks
# -------------------------------------
	jal	spawn_rocks


#            Get User Input
# -------------------------------------
	jal	_getKeyPress
	
	move	$s2, $v0
	li	$t0, 0x42
	beq	$s2, $t0, exit		# if the user pressed the center button,
					# exit
	
	beqz	$s2, game_loop		# if the user entered nothing, continue
					# with the game 
	
	input_move_left:
	li	$t0, 0xE2
	bne	$s2, $t0, input_move_right
					# proceed only if the user pressed the
					# 'move left' button
	
	addi	$s0, $s0, -2		# Adjust the top corner of the frog
	jal	move_frog
	
	j	game_loop
	
	input_move_right:
	li	$t0, 0xE3
	bne	$s2, $t0 input_move_up	# proceed only if the user pressed the
					# 'move right' button
	addi	$s0, $s0, 2		# Move the top corner of the frog
	jal	move_frog
	
	j	game_loop

	input_move_up:
	li	$t0, 0xE0
	bne	$s2, $t0 input_move_down# proceed only if the user pressed the
					# 'move up' button

	addi	$s1, $s1, -2
	jal	move_frog
	
	j	game_loop
	
	input_move_down:
	# proceed only if the user pressed the 'move down' button. At this point,
	# down is the only non-checked value, so it must be down.
	addi	$s1, $s1, 2		# move the top right corner of the frog
	jal	move_frog
	
	j	game_loop
	
exit:	li	$v0, 10
	syscall

game_over:
	la	$a0, msg_game_over
	li	$v0, 4
	syscall
	
	la	$a0, msg_newline
	li	$v0 4
	syscall
	
	la	$a0, msg_player_score
	li	$v0, 4
	syscall
	
	lw	$a0, player_score
	li	$v0, 1
	syscall
	
	li	$v0, 10
	syscall

#------------------------------------------------------------------------------               
# void check_win()
#   Called every time a frog has moved
#
#  Register usages:
#	$t0 => player score
#	$t1 => address in memory of player score
#
# arguments:
# trashes: $t0, $t1
# returns: none
#------------------------------------------------------------------------------
check_win:
	li	$t0, 6
	bne	$s1, $t0, check_win_end
	
	# if the top two frog locations correspond to any winning locations, call win
	# othrwise call death
	
	# first lilly pad
	li	$t0, 0
	beq	$s0, $t0, win
	
	li	$t0, 1
	beq	$s0, $t0, win
	
	li	$t0, 2
	beq	$s0, $t0, win
	
	li	$t0, 3
	beq	$s0, $t0, win

	li	$t0, 4
	beq	$s0, $t0, win
	
	# Second lilly pad
	li	$t0, 28
	beq	$s0, $t0, win
	
	li	$t0, 29
	beq	$s0, $t0, win
	
	li	$t0, 30
	beq	$s0, $t0, win
	
	li	$t0, 31
	beq	$s0, $t0, win
	
	li	$t0, 32
	beq	$s0, $t0, win
	
	# Third lilly pad
	li	$t0, 58
	beq	$s0, $t0, win
	
	li	$t0, 59
	beq	$s0, $t0, win
	
	li	$t0, 60
	beq	$s0, $t0, win
	
	li	$t0, 61
	beq	$s0, $t0, win
	
	li	$t0, 62
	beq	$s0, $t0, win
	
	# if the player has landed in row 6 and has not landed on any of
	# the designated spaces he/she is dead
	j	death
	
	check_win_end:
	jr	$ra


#------------------------------------------------------------------------------               
# void win()
#   Called when frog has landed on a lilly pad 
#
#  Register usages:
#	$t0 => player score
#	$t1 => address in memory of player score
#
# arguments:
# trashes: $t0, $t1
# returns: none
#------------------------------------------------------------------------------
win:
	lw	$t0, player_score
	addi	$t0, $t0, 100
	
	sw	$t0, player_score
	
	la	$a0, msg_player_score
	li	$v0, 4
	syscall
	
	move	$a0, $t0
	li	$v0, 1
	syscall
	
	la	$a0, msg_newline
	li	$v0, 4
	syscall
	
	j	reset_game

#------------------------------------------------------------------------------               
# void death()
#   Called when the frog has died. R.I.P. frog. Resets the game board and takes 
#	away a life
#
#  Register usages:
#	$t0 => number of lives left
#	$t1 => address in memory of player lives
#
# arguments:
# trashes: $t0, $t1
# returns: none
#------------------------------------------------------------------------------
death:
	lb	$t0, player_lives
	addi	$t0, $t0, -1
	la	$t1, player_lives
	sb	$t0, 0($t1)
	
	la	$a0, msg_lives_left
	li	$v0, 4
	syscall
	
	move	$a0, $t0
	li	$v0, 1
	syscall
	
	li	$v0, 4
	la	$a0, msg_newline
	syscall
	
	
	beqz	$t0, game_over
	
	j	reset_game

#------------------------------------------------------------------------------               
# void spawn_rocks()
#   Spawn a new rock if necessiary. Rocks are spwaned by placing a 2 in a rock's
#   respective color bit which gets moved and repicated by the move_rock functions
#   The length is also randomly generated.
#
#  Register usages:
#    $s2 = row length
#    $s3 = address of the new color value. Gets updated at the end to be 1 (lava).
#
# arguments: $a0 the row to move, $a1 the color to add
# trashes: $t0, $s2, $s3
# returns: none
#------------------------------------------------------------------------------
spawn_rocks:

	# set up the random number generator
	li	$v0, 30		# get time in milliseconds (as a 64-bit value)
	syscall

	move	$t0, $a0	# save the lower 32-bits of time

	# seed the random generator (just once)
	li	$a0, 1		# random generator id (will be used later)
	move 	$a1, $t0	# seed from time
	li	$v0, 40		# seed random number generator syscall
	syscall

	la	$t0, stone1_color	# load the current stone 1 color
	li	$t1, 2			# load system stone color
	beq	$t0, $t1, spawn_stone_2	# if the stone's color is the stone color,
					# skip the potential to spawn a stone
	
	# stones have a 1/10 change of spawning
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 10		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number

	bne	$0, $a0, spawn_stone_2	# if the random number is equal to zero,
					# we spawn a stone
	
	li	$t1, 2
	sb	$t1, 0($t0)	# store 2 in stone1_color
	
	# generate a number for the length of the stone
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 4		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number
	addi	$a0, $a0, 8
	
	la	$t0, stone1_length
	sb	$a0, 0($t0)
	
	spawn_stone_2:

	la	$t0, stone2_color	# load the current stone 1 color
	li	$t1, 2			# load system stone color
	beq	$t0, $t1, spawn_stone_3	# if the stone's color is the stone color,
					# skip the potential to spawn a stone
	
	# stones have a 1/10 change of spawning
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 10		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number

	bne	$0, $a0, spawn_stone_3	# if the random number is equal to zero,
					# we spawn a stone
	
	li	$t1, 2
	sb	$t1, 0($t0)	# store 2 in stone1_color
	
	# generate a number for the length of the stone
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 4		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number
	addi	$a0, $a0, 8
	
	la	$t0, stone2_length
	sb	$a0, 0($t0)

	spawn_stone_3:
	la	$t0, stone3_color	# load the current stone 1 color
	li	$t1, 2			# load system stone color
	beq	$t0, $t1, spawn_stone_4	# if the stone's color is the stone color,
					# skip the potential to spawn a stone
	
	# stones have a 1/10 change of spawning
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 10		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number

	bne	$0, $a0, spawn_stone_4	# if the random number is equal to zero,
					# we spawn a stone
	
	li	$t1, 2
	sb	$t1, 0($t0)	# store 2 in stone1_color
	
	# generate a number for the length of the stone
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 4		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number
	addi	$a0, $a0, 8
	
	la	$t0, stone3_length
	sb	$a0, 0($t0)
	
	spawn_stone_4:
	la	$t0, stone4_color	# load the current stone 1 color
	li	$t1, 2			# load system stone color
	beq	$t0, $t1, spawn_stone_5	# if the stone's color is the stone color,
					# skip the potential to spawn a stone
	
	# stones have a 1/10 change of spawning
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 10		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number

	bne	$0, $a0, spawn_stone_5	# if the random number is equal to zero,
					# we spawn a stone
	
	li	$t1, 2
	sb	$t1, 0($t0)	# store 2 in stone1_color
	
	# generate a number for the length of the stone
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 4		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number
	addi	$a0, $a0, 8
	
	la	$t0, stone4_length
	sb	$a0, 0($t0)

	spawn_stone_5:
	la	$t0, stone5_color	# load the current stone 1 color
	li	$t1, 2			# load system stone color
	beq	$t0, $t1, spawn_stone_6	# if the stone's color is the stone color,
					# skip the potential to spawn a stone
	
	# stones have a 1/10 change of spawning
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 10		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number

	bne	$0, $a0, spawn_stone_6	# if the random number is equal to zero,
					# we spawn a stone
	
	li	$t1, 2
	sb	$t1, 0($t0)	# store 2 in stone1_color
	
	# generate a number for the length of the stone
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 4		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number
	addi	$a0, $a0, 8
	
	la	$t0, stone5_length
	sb	$a0, 0($t0)
	
	spawn_stone_6:
	la	$t0, stone6_color	# load the current stone 1 color
	li	$t1, 2			# load system stone color
	beq	$t0, $t1, spawn_stone_end	# if the stone's color is the stone color,
					# skip the potential to spawn a stone
	
	# stones have a 1/10 change of spawning
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 10		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number

	bne	$0, $a0, spawn_stone_end	# if the random number is equal to zero,
					# we spawn a stone
	
	li	$t1, 2
	sb	$t1, 0($t0)	# store 2 in stone1_color
	
	# generate a number for the length of the stone
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 4		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
				# $a0 now holds the random number
	addi	$a0, $a0, 8
	
	la	$t0, stone6_length
	sb	$a0, 0($t0)
	
	spawn_stone_end:
	jr	$ra


#------------------------------------------------------------------------------               
# void generate_velocities()
#   Fill the velocity array and generate a velocity for each row of stones
#
#  Register usages:
#    $s2 = row length
#    $s3 = address of the new color value. Gets updated at the end to be 1 (lava).
#
# arguments: $a0 the row to move, $a1 the color to add
# trashes: $t0, $s2, $s3
# returns: none
#------------------------------------------------------------------------------
generate_velocities:

# PART 1) Find the velocities 
# for each stone's row
#-------------------------------

	# PART 1) Find the velocities 
# for each stone's row
#-------------------------------

	# PART 1) Find the velocities 
# for each stone's row
#-------------------------------

	# set up the random number generator
	li	$v0, 30		# get time in milliseconds (as a 64-bit value)
	syscall

	move	$t0, $a0	# save the lower 32-bits of time

	# seed the random generator (just once)
	li	$a0, 1		# random generator id (will be used later)
	move 	$a1, $t0	# seed from time
	li	$v0, 40		# seed random number generator syscall
	syscall
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 3		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone1_v	# store the velocity for stone 1
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 3		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone2_v	# store the velocity for stone 2
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 3		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone3_v	# store the velocity for stone 2
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 3		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone3_v	# store the velocity for stone 4
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 2		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone4_v	# store the velocity for stone 4

	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 3		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone5_v	# store the velocity for stone 5
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 2		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone5_v	# store the velocity for stone 5
	
	li	$a0, 1		# as said, this id is the same as random generator id
	li	$a1, 2		# upper bound of the range
	li	$v0, 42		# load the instruction for get ranndom number
	syscall			# get the random number
	addi	$a0, $a0, 1	# add 1 to ensure we don't get a zero velocity

	# $a0 now holds the random number
	sb	$a0, stone6_v	# store the velocity for stone 6

 
# PART 2) fill the velocity array 
# which is used to track where 
# the frog moves while he/she is 
# on a rock
#-------------------------------

	la	$t0, velocities	# load the address of the velocity array
	
	# proceeding downwards.....
	
	# upper black (safe) region
	li	$t1, 0
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Stone 1
	addi	$t0, $t0, 8
	lb	$t1, stone1_v
	not	$t1, $t1	# invert the stone's velocity to use with the frog's movements
	addi	$t1, $t1, 1
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Stone 2
	addi	$t0, $t0, 8
	lb	$t1, stone2_v
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Stone 3
	addi	$t0, $t0, 8
	lb	$t1, stone3_v
	not	$t1, $t1
	addi	$t1, $t1, 1	# invert the stone's velocity to use with the frog's movements
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Stone 4
	addi	$t0, $t0, 8
	lb	$t1, stone4_v
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Stone 5
	addi	$t0, $t0, 8
	lb	$t1, stone5_v
	not	$t1, $t1
	addi	$t1, $t1, 1
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Stone 6
	addi	$t0, $t0, 8
	lb	$t1, stone6_v
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	# Lower black (safe) region
	addi	$t0, $t0, 8
	li	$t1, 0
	sb	$t1, 0($t0)
	sb	$t1, 1($t0)
	sb	$t1, 2($t0)
	sb	$t1, 3($t0)
	sb	$t1, 4($t0)
	sb	$t1, 5($t0)
	sb	$t1, 6($t0)
	sb	$t1, 7($t0)
	
	jr	$ra	# return

#------------------------------------------------------------------------------               
# void move_stone_left(int row, int address_of_stone_length, int address_of_color)
#   move a stone with length 'length' to the left one pixel
#	$a0 = row, $a1 = row length, $a2 = address of color to introduce into the playing field
#
#  Register usages:
#    $s2 = row length
#    $s3 = address of the new color value. Gets updated at the end to be 1 (lava).
#
# arguments: $a0 the row to move, $a1 the color to add
# trashes: $t0, $s2, $s3
# returns: none
#------------------------------------------------------------------------------
move_stone_left:
	
	# --------
	# Prologue
	# --------
	addi	$sp, $sp -16
	sw	$ra, 0($sp)
	sw	$s2, 4($sp)
	sw	$s3, 8($sp)
	sw	$s4, 12($sp)
	
	lb	$s2, 0($a1)	# $s2 = stone_length
	addi	$t0, $s2, -1
	sb	$t0, 0($a1)
	
	lb	$s3, 0($a2)	# load the value of the new color as a constant argument for the movement of
				# the stone
	move	$s4, $a0
				
	beq	$t0, $0, change_color

#move_stone_right_loop:	# when every pixel i nthe stone's length has been shifted over once, we branch
#	beqz	$s2, move_stone_right_end
	
	addi	$a0, $s4, 0	# load the initial row number
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 1 over 1 and use $a1 as the new color

	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 2 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 3 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 4 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 5 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 6 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_left	# move row $a0 + 7 over 1 and use $a1 as the new color
	
	
	addi	$s2, $s2, -1	# decrease the length remaining of the rock
				# when this values reaches 0, all rows of the rock will be completly 
				# shifted over by 1 pixel

	#j	move_stone_right_loop
	j	move_stone_left_end
	

	# the rock has been fully introduced onto the screen, set the new color value to be 1 for lava
	# consequentially in further movements, the lava will be moving over by 1 and appear to remain
	# constant
	change_color:
	li	$t0, 1
	sb	$t0, 0($a2)

	move_stone_left_end:
	# --------
	# Epilogue
	# --------
	lw	$ra, 0($sp)
	lw	$s2, 4($sp)
	lw	$s3, 8($sp)
	lw	$s4, 12($sp)
	addi	$sp, $sp, 12
	
	jr	$ra


#------------------------------------------------------------------------------               
# void move_stone_right(int row, int address_of_stone_length, int address_of_color)
#   move a stone with length 'length' to the right one pixel
#	$a0 = row, $a1 = row length, $a2 = address of color to introduce into the playing field
#
#  Register usages:
#    $s2 = row length
#    $s3 = address of the new color value. Gets updated at the end to be 1 (lava).
#
# arguments: $a0 the row to move, $a1 the color to add
# trashes: $t0, $s2, $s3
# returns: none
#------------------------------------------------------------------------------
move_stone_right:
	
	# --------
	# Prologue
	# --------
	addi	$sp, $sp -16
	sw	$ra, 0($sp)
	sw	$s2, 4($sp)
	sw	$s3, 8($sp)
	sw	$s4, 12($sp)
	
	lb	$s2, 0($a1)	# $s2 = stone_length
	addi	$t0, $s2, -1
	sb	$t0, 0($a1)
	
	lb	$s3, 0($a2)	# load the value of the new color as a constant argument for the movement of
				# the stone
	move	$s4, $a0
				
	beq	$t0, $0, right_change_color

#move_stone_right_loop:	# when every pixel i nthe stone's length has been shifted over once, we branch
#	beqz	$s2, move_stone_right_end
	
	addi	$a0, $s4, 0	# load the initial row number
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 1 over 1 and use $a1 as the new color

	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 2 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 3 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 4 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 5 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 6 over 1 and use $a1 as the new color
	
	addi	$s4, $s4, 1	# increase the row number by 1
	move	$a0, $s4	# load the row number + 1 into $a1
	move	$a1, $s3	# load the color into $a1
	jal	move_right	# move row $a0 + 7 over 1 and use $a1 as the new color
	
	
	addi	$s2, $s2, -1	# decrease the length remaining of the rock
				# when this values reaches 0, all rows of the rock will be completly 
				# shifted over by 1 pixel

	#j	move_stone_right_loop
	j	move_stone_right_end
	

	# the rock has been fully introduced onto the screen, set the new color value to be 1 for lava
	# consequentially in further movements, the lava will be moving over by 1 and appear to remain
	# constant
	right_change_color:
	li	$t0, 1
	sb	$t0, 0($a2)

	move_stone_right_end:
	# --------
	# Epilogue
	# --------
	lw	$ra, 0($sp)
	lw	$s2, 4($sp)
	lw	$s3, 8($sp)
	lw	$s4, 12($sp)
	addi	$sp, $sp, 12
	
	jr	$ra

#------------------------------------------------------------------------------               
# void move_left(int row, int new_pixel)
#   shit a row across the screen by one pixel. The new pixel is taken from the
#   argument $a1
#
#  Register usages:
#    $s2 = previous
#    $s3 = count
#    $s4 = next
#    $s5 = current row (y value)
#
# arguments: $a0 the row to move, $a1 the pixel to add to the row being shifted
# trashes: $s2 => prev, $s3 => count, $s4 => next, $s5 => current row, $s6 => new pixel color
# returns: none
#------------------------------------------------------------------------------
move_left:

	# --------
	# Prologue
	# --------
	addi	$sp, $sp, -24
	sw	$ra, 0($sp)
	sw	$s2, 4($sp)
	sw	$s3, 8($sp)
	sw	$s4, 12($sp)
	sw	$s5, 16($sp)
	sw	$s6, 20($sp)
	
	move	$s6, $a1	# store the new pixel to be added
	li	$s3, 64		# $s3 is the count variable
	
	move	$a1, $a0	# x's are col's of the LED display
	li	$a0, 0		# y's are row's of the LED display
	jal	_getLED		# _getLED($a0, $a1) => _getLED(int row, int col)
	
	move	$s2, $v0	# store the value of the previous LED
	
	move	$a2, $s6
	jal	_setLED
	
	move_left_loop:
	beq	$s3, $0, move_left_end	#loop executes while col's > 64
	
	move	$a0, $s3	# col number (x value) = count
				# row number (y value) stays the same
	jal	_getLED		# get the LED at x = count & y = $a1 (which is the row number 
				# from the intial argument)
	
	move	$s4, $v0	# move the LED value into the next variable
	
	move	$a2, $s2	# move the previous LED into the argument list for _setLED
	jal	_setLED		# the coordinates are the same from the past call of _getLED
				# except this time we are setting it not saving it
	move	$s2, $s4	# previous = next
	addi	$s3, $s3, -1	# add 1 to the current column
	
	j	move_left_loop	# loop executes while column number is > 0
	
	move_left_end:
	# --------
	# Epilogue
	# --------
	lw	$ra, 0($sp)
	lw	$s2, 4($sp)
	lw	$s3, 8($sp)
	lw	$s4, 12($sp)
	lw	$s5, 16($sp)
	lw	$s6, 20($sp)
	addi	$sp, $sp, 24
	
	jr	$ra

#------------------------------------------------------------------------------               
# void move_right(int row, int new_pixel)
#   shit a row across the screen by one pixel. The new pixel is taken from the
#   argument $a1
#
#  Register usages:
#    $s2 = previous
#    $s3 = count
#    $s4 = next
#    $s5 = current row (y value)
#
# arguments: $a0 the row to move, $a1 the pixel to add to the row being shifted
# trashes: $s2 => prev, $s3 => count, $s4 => next, $s5 => current row, $s6 => new pixel color
# returns: none
#------------------------------------------------------------------------------
move_right:

	# --------
	# Prologue
	# --------
	addi	$sp, $sp, -24
	sw	$ra, 0($sp)
	sw	$s2, 4($sp)
	sw	$s3, 8($sp)
	sw	$s4, 12($sp)
	sw	$s5, 16($sp)
	sw	$s6, 20($sp)
	
	move	$s6, $a1	# store the new pixel to be added
	li	$s3, 0		# $s3 is the count variable
	
	move	$a1, $a0	# x's are col's of the LED display
	li	$a0, 0		# y's are row's of the LED display
	jal	_getLED		# _getLED($a0, $a1) => _getLED(int row, int col)
	
	move	$s2, $v0	# store the value of the previous LED
	
	move	$a2, $s6
	jal	_setLED
	
	move_right_loop:
	li	$t0, 64
	bge	$s3, $t0, move_right_end	#loop executes while col's < 64
	
	move	$a0, $s3	# col number (x value) = count
				# row number (y value) stays the same
	jal	_getLED		# get the LED at x = count & y = $a1 (which is the row number 
				# from the intial argument)
	
	move	$s4, $v0	# move the LED value into the next variable
	
	move	$a2, $s2	# move the previous LED into the argument list for _setLED
	jal	_setLED		# the coordinates are the same from the past call of _getLED
				# except this time we are setting it not saving it
	move	$s2, $s4	# previous = next
	addi	$s3, $s3, 1	# add 1 to the current column
	
	j	move_right_loop	# loop executes while column number is < 64
	
	move_right_end:
	# --------
	# Epilogue
	# --------
	lw	$ra, 0($sp)
	lw	$s2, 4($sp)
	lw	$s3, 8($sp)
	lw	$s4, 12($sp)
	lw	$s5, 16($sp)
	lw	$s6, 20($sp)
	addi	$sp, $sp, 24
	
	jr	$ra

#------------------------------------------------------------------------------               
# void move_frog()
#   the frog gets redrawn based on it's top left corner. To move the frog,
#   adjust the top left corner by changing $s0 and $s1 to the new location
#
# arguments: none
# trashes: none
# returns: none
#------------------------------------------------------------------------------
move_frog:

	# --------
	# Prologue
	# --------
	addi	$sp, $sp, -8
	sw	$ra, 0($sp)

	#move	$a0, $s0
	#li	$v0, 1
	#3syscall
	
	#move	$a0, $s1
	#syscall
	
	# Check to see if the frog landed on a lilly pad
	jal	check_win
	
	# Check to see if the frog is moving to it's death (one of the LED's is red)
	addi	$a0, $s0, 0
	addi	$a1, $s1, 0
	jal	_getLED
	
	li	$t0, 1
	beq	$v0, $t0, death 
	
	addi	$a0, $s0, 0	# (x, y) = green
	addi	$a1, $s1, 0
	addi	$a2, $0,  3
	jal	_setLED
	
	addi	$a0, $s0, 1	# (x + 1, y) = green 
	addi	$a1, $s1, 0
	jal	_getLED
	
	li	$t0, 1
	beq	$v0, $t0, death
	
	
	addi	$a2, $0,  3
	jal	_setLED
	
	addi	$a0, $s0, 1 	# (x + 1, y + 1) = green
	addi	$a1, $s1, 1
	addi	$a2, $0,  3
	jal	_setLED
	
	addi	$a0, $s0, 0	# (x, y + 1) = green
	addi	$a1, $s1, 1
	addi	$a2, $0,  3
	jal	_setLED	
			
	# --------
	# Epilogue
	# --------
	lw	$ra, 0($sp)
	addi	$sp, $sp, 8
	
	jr	$ra
#------------------------------------------------------------------------------               
# void draw_field()
#   draws the playing field represented by the array memory location
#   
# arguments: none
# trashes: $t0
# returns: none
#------------------------------------------------------------------------------
draw_field:
	# --------
	# Prologue
	# --------
	addi	$sp, $sp, -12
	sw	$ra, 0($sp)
	sw	$s0, 4($sp)
	sw	$s1, 8($sp)

	li	$s0, 0	
rows:
	li	$s1, 0
cols:
	
	move	$a0, $s0
	move	$a1, $s1
	jal	address_in_array_of
	
	move	$a0, $s1
	move	$a1, $s0
	
	move	$a2, $v0
	jal	_setLED
	
	addi $s1, $s1, 1		# change the column
	
	slti $t0, $s1, 64		# THIS VALUE MUST BE CHANGED TO:
						# number of columns in array
	bne $t0, $zero, cols
	
	addi $s0, $s0, 1		# change the row
	slti $t0, $s0, 64		# THIS VALUE MUST BE CHANGED TO:
						# number of rows in array
	bne $t0, $zero, rows
		
	#---------
	# Epilogue
	#---------
	lw	$s1, 8($sp)
	lw	$s0, 4($sp)
	lw	$ra, 0($sp)
	addi	$sp, $sp, 12
	jr	$ra			# Return
	
#------------------------------------------------------------------------------
# int address_in_array_of(int x, int y)
#   returns the value of the array at the location (x, y)
#
#  warning:   x and y are assumed to be legal values (0-7,0-7)
#  arguments: $a0 holds x, $a1 holds y
#  trashes:   $t0-$t3
#  returns:   $v0 holds the value maze at the position
#------------------------------------------------------------------------------
address_in_array_of:
	la	$t0, array
	
	sll	$a0, $a0, 6	# THIS VALUE MUST BE CHANGED TO: 
				#	   	log2(number_of_array_columns)
	
	add 	$v0, $a0, $a1
	
	add 	$v0, $v0, $t0

	lb	$v0, 0($v0)
	jr   	$ra
	
	
	#y * 16 bytes + (x / 4)
	
#------------------------------------------------------------------------------
# void _setLED(int x, int y, int color)
#   sets the LED at (x,y) to color
#   color: 0=off, 1=red, 2=orange, 3=green
#
# warning:   x, y and color are assumed to be legal values (0-63,0-63,0-3)
# arguments: $a0 is x, $a1 is y, $a2 is color 
# trashes:   $t0-$t3
# returns:   none
#------------------------------------------------------------------------------
_setLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll	$t0,$a1,4      # y * 16 bytes
	srl	$t1,$a0,2      # x / 4
	add	$t0,$t0,$t1    # byte offset into display
	li	$t2,0xffff0008	# base address of LED display
	add	$t0,$t2,$t0    # address of byte with the LED
	# now, compute led position in the byte and the mask for it
	andi	$t1,$a0,0x3    # remainder is led position in byte
	neg	$t1,$t1        # negate position for subtraction
	addi	$t1,$t1,3      # bit positions in reverse order
	sll	$t1,$t1,1      # led is 2 bits
	# compute two masks: one to clear field, one to set new color
	li	$t2,3		
	sllv	$t2,$t2,$t1
	not	$t2,$t2        # bit mask for clearing current color
	sllv	$t1,$a2,$t1    # bit mask for setting color
	# get current LED value, set the new field, store it back to LED
	lbu	$t3,0($t0)     # read current LED value	
	and	$t3,$t3,$t2    # clear the field for the color
	or	$t3,$t3,$t1    # set color field
	sb	$t3,0($t0)     # update display
	jr	$ra

#------------------------------------------------------------------------------
# int _getLED(int x, int y)
#   returns the value of the LED at position (x,y)
#
#  warning:   x and y are assumed to be legal values (0-63,0-63)
#  arguments: $a0 holds x, $a1 holds y
#  trashes:   $t0-$t2
#  returns:   $v0 holds the value of the LED (0, 1, 2, 3)
#------------------------------------------------------------------------------
_getLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll  $t0,$a1,4      # y * 16 bytes
	srl  $t1,$a0,2      # x / 4
	add  $t0,$t0,$t1    # byte offset into display
	la   $t2,0xffff0008
	add  $t0,$t2,$t0    # address of byte with the LED
	# now, compute bit position in the byte and the mask for it
	andi $t1,$a0,0x3    # remainder is bit position in byte
	neg  $t1,$t1        # negate position for subtraction
	addi $t1,$t1,3      # bit positions in reverse order
    	sll  $t1,$t1,1      # led is 2 bits
	# load LED value, get the desired bit in the loaded byte
	lbu  $t2,0($t0)
	srlv $t2,$t2,$t1    # shift LED value to lsb position
	andi $v0,$t2,0x3    # mask off any remaining upper bits
	jr   $ra


#------------------------------------------------------------------------------
# int _getKeyPress(void)
#	returns the key last pressed, unless there is none
#
# trashes: $t0-$t1
# returns in $v0:
#	0	No key pressed
# 	0x42	Middle button pressed
# 	0xE0	Up arrow 
# 	0xE1	Down arrow 
# 	0xE2	Left arrow 
# 	0xE3 	Right arrow
#------------------------------------------------------------------------------
_getKeyPress:
	la	$t1, 0xffff0000			# status register
	li	$v0, 0				# default to no key pressed
	lw	$t0, 0($t1)			# load the status
	beq	$t0, $zero, _keypress_return	# no key pressed, return
	lw	$v0, 4($t1)			# read the key pressed
	_keypress_return:
	jr $ra
